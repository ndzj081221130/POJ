package p1125_bellmanford_wa;import java.util.Scanner;public class Main {	/**	 * @param args	 */	public static void main(String[] args) {		Scanner scanner = new Scanner(System.in);		int n = scanner.nextInt();		while(n!=0){ 			int[][] edges = new int[n][n];			for (int i = 0; i < edges.length; i++) {				for (int j = 0; j < edges.length; j++) {					if(i!=j)						edges[i][j] = Integer.MAX_VALUE;					else {						edges[i][j] = 0;					}				}			}			for (int i = 0; i < n; i++) {				int edge_i = scanner.nextInt();				for (int j = 0; j < edge_i; j++) {					edges[i][scanner.nextInt()-1] = scanner.nextInt();				}			}						handle(n,edges);			n = scanner.nextInt();		}	}	private static void handle(int n, int[][] edges) {		// TODO Auto-generated method stub		int min = Integer.MAX_VALUE;		int index = -1;		for (int i = 0; i < edges.length; i++) {			int cal = bellman_ford(edges,i,n);//			System.out.println(cal);			if(cal == -1)continue;			if(cal < min)			{				min = cal;				index = i;			}		}		if(min == Integer.MAX_VALUE)			System.out.println("disjoint");		else			System.out.println((index+1)+" " + min);	}	static int bellman_ford(int[][]edges,int v,int n){		int cost = 0;		int w;		int []dist = new int[n];		int []path = new int[n];				for (int i = 0; i < n; i++) {			dist[i]  = edges[v][i];			if (i!=v && dist[i] < Integer.MAX_VALUE) {				path[i] = v;			}else {				path[i] = -1;			}					}				for (int k = 2; k < n; k++) {			for (int u = 0; u < n; u++) {				if (u!=v) {					for (int i = 0; i < n; i++) {						w = edges[i][u];						if (w>0 && w < Integer.MAX_VALUE && dist[u] > dist[i] + w) {							dist[u] = dist[i] + w;							path[u] = i;						}					}									}			}		}				for (int i = 0; i < path.length; i++) {			if(dist[i] > cost)				 				cost = dist[i];		}		return cost;	}}