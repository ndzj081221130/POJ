package p3259_wa;import java.util.Scanner;public class Main2 {	/**	 * @param args	 */	static boolean checkReplicateEdge(Path[] paths,Path path,int index){		 		for (int k = 0;k<index;k++) {			Path p = paths[k];			if (p.getStart() == path.getStart() && p.getEnd() == path.getEnd() && p.getWeight() > path.getWeight()) {				p.setWeight(path.weight);				return true;			}		}		return false;	}	public static void main(String[] args) { 		Scanner scanner = new Scanner(System.in);		int F = scanner.nextInt();		for (int i = 0; i < F; i++) {			int N = scanner.nextInt();			int M = scanner.nextInt();			int W = scanner.nextInt();//						int[][]edges = new int[N+1][N+1];			for (int j = 0; j < edges.length; j++) {				for (int j2 = 0; j2 < edges.length; j2++) {					if(j == j2)						edges[j][j2] = 0;					else						edges[j][j2] = Integer.MAX_VALUE;				}			}			int index = 0;			for (int j = 0; j < M; j++) {				int start = scanner.nextInt();				int end = scanner.nextInt();				int weight = scanner.nextInt();				if( edges[start][end] > weight)					edges[start][end] = weight;				if(edges[end][start] > weight)					edges[end][start] = weight; 			}			for (int j = 0; j < W; j++) {				int start_m = scanner.nextInt();				int end_m = scanner.nextInt();				int weight_m = scanner.nextInt();				if( edges[start_m][end_m] > weight_m)					edges[start_m][end_m] = 0-weight_m; 			}			Path[]paths = new Path[2*M+W];			for (int j = 1; j < edges.length; j++) {				for (int j2 = 1; j2 < edges.length; j2++) {					if (j!=j2 && edges[j][j2] < Integer.MAX_VALUE) { 						paths[index++] = new Path(j, j2, edges[j][j2]);					}				}			}			output(N,paths);		}	}	private static void output(int n, Path[] paths) {		// TODO Auto-generated method stub		if (bellmanford(n,paths,1) == false) {			System.out.println("YES");		}else {			System.out.println("NO");		}	}	private static boolean bellmanford(int n, Path[] paths,int s) { 		int[] d = new int[n+1];		for (int i = 0; i < d.length; i++) {			d[i] = Integer.MAX_VALUE;		}		d[s] = 0;		for (int i = 1; i <= n; i++) {			for (int j = 0; j < paths.length; j++) { 				if(paths[j] != null)				relax(paths[j],d);			}		} 		for(Path path:paths){			if ( path!=null && d[path.getEnd()] > d[path.getStart()] + path.getWeight()) {				return false;			}		}		return true;	}	private static void relax(Path path,int[]d) {		// TODO Auto-generated method stub		int u = path.getStart();		int v = path.getEnd();		if (d[v] > d[u] + path.getWeight()) {			d[v] = d[u] + path.getWeight();		}	}	static class Path{		int start;		int end;		int weight;		Path(int s,int e,int w){			start =s;			end=e;			weight = w;		}		public int getStart() {			return start;		}		public void setStart(int start) {			this.start = start;		}		public int getEnd() {			return end;		}		public void setEnd(int end) {			this.end = end;		}		public int getWeight() {			return weight;		}		public void setWeight(int weight) {			this.weight = weight;		}			}}