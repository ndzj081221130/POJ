package p2485_prim_TLE;import java.util.Scanner;public class Main {	private int prim[][];// 图的邻接矩阵	private boolean visit[];// 记录顶点是否被访问，即是否加入到了顶点集U	private int Len[]; // Len[i] 记录顶点集U到i的最短距离,即U中所有点到i的距离之最小者。	private int n;// 顶点数	int ans;	public Main(int n, int[][] prim) {		this.n = n;		this.prim = prim;		visit = new boolean[n + 1];// 开始时都未访问		Len = new int[n + 1];	}	private int prim_solve(int xx) {		int minx;		int k = 0;		ans = -1;		for (int i = 1; i <= n; i++) {			Len[i] = prim[xx][i];		}		Len[xx] = 0;		visit[xx] = true; // 此时U中只有起点xx		for (int i = 1; i < n; i++) // 注意：因为xx起点已经访问过，所以只需再访问n-1个		{			minx = Integer.MAX_VALUE;			for (int j = 1; j <= n; j++) // 在所有u∈U,v∈V－U的边(u,v)∈E中,找一条权最小的边(u,v)			{ // 这里找的是：与顶点集U相邻的距离最小值				if (!visit[j] && Len[j] < minx) {					minx = Len[j];					k = j;				}			}			visit[k] = true; // 找到，加入U			if (ans < minx) // 保存最短路径中最大的一条边			{				ans = minx;			}			// i=1时，U中只有起点xx和新加入的k，Len[j]与prim[k][j]比较：就是比较xx到j的距离和新加入U的k顶点到j的距离			// 之后，Len[j]就是U到j的最短距离啦，这样把U中所有顶点看成一个，Len[j]就是U到j(V-U中任意一个)的最短距离			// 以此类推，i>1 时，每次都把原来的顶点集U到j的距离和新加入的k到j的距离比较，这样得到了新U到j的最短距离			// 从而,就得到了新U到V-U中任一顶点的距离，保存在 Len中			for (int j = 1; j <= n; j++) {				if (!visit[j] && Len[j] > prim[k][j]) {					Len[j] = prim[k][j];				}			}		}		return ans;	}	public static void main(String[] args) {		Scanner in = new Scanner(System.in);		int T = in.nextInt();		while ((T--) > 0) {			int n = in.nextInt();			int[][] prim = new int[n + 1][n + 1];			for (int i = 1; i <= n; i++)				for (int j = 1; j <= n; j++) {					prim[i][j] = in.nextInt();				}			Main m = new Main(n, prim);			System.out.printf("%d\n", m.prim_solve(1)); // 以第一个顶点开始，也可以是其他		}	}}