package p1035spell_check_ac;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;//import java.util.Scanner;public class Main {	/**	 * @param args	 */	public static void main(String[] args) {		long start = System.currentTimeMillis();		// Scanner scanner = new Scanner(System.in);		BufferedReader cin = new BufferedReader(				new InputStreamReader(System.in));		ArrayList<Word>[] library = new ArrayList[15];		for (int i = 0; i < library.length; i++) {			library[i] = new ArrayList<Word>();		}		// String<Word>		String string;		try {			string = cin.readLine();			int index = 0;			while (string.equals("#") == false) {				// library.add(new Word(index, string));				int length = string.length();				library[length - 1].add(new Word(index, string));				index++;				string = cin.readLine();			}			for (int i = 0; i < library.length; i++) {				QuickSortL(0, library[i].size() - 1, library[i]);			}			long ea = System.currentTimeMillis();			string = cin.readLine();// scanner.next();			long mid = System.currentTimeMillis();			while (string.equals("#") == false) {				check(library, string);				string = cin.readLine();// scanner.next();			}			// System			long end = System.currentTimeMillis();			// System.out.println(mid-start);			// System.out.println(end - mid);//			System.out.println(end - start);		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}// scanner.next();	}	private static void check(ArrayList<Word>[] library, String testString) {		ArrayList<Word> res = new ArrayList<Word>();		Word testWord = new Word(-1, testString);		int length = testString.length();		ArrayList<String> family = getFamily(testString);// 测试单词的family。若果lib		// 包含的话，那么加入res		long s1 = System.currentTimeMillis();		if (length - 1 >= 0) {// lib[a]			if (library[length - 1].contains(testWord)) {				System.out.println(testString + " is correct");				return;			} else {				for (String str : family) {					int in = BinarySearch(str, library[length - 1]);					if (in != -1							&& res.contains(library[length - 1].get(in)) == false) {						res.add(library[length - 1].get(in));					}				}				// for (Word w : library[length - 1]) {				// if (w.getWord().equals(str) && res.contains(w) == false) {				// res.add(w);				// }				// }			}		}		if (length < 15) {// lib[a+1]			if (library[length].contains(testWord)) {				System.out.println(testString + " is correct");				return;			} else {				for (String str : family) {					int in = BinarySearch(str, library[length]);					if (in != -1							&& res.contains(library[length].get(in)) == false) {						res.add(library[length].get(in));					}				}				// for (Word w : library[length]) {				// if (w.getWord().equals(str) && res.contains(w) == false) {				// res.add(w);				// }				// }			}		}		if (length - 2 >= 0) {			if (library[length - 2].contains(testWord)) {				System.out.println(testString + " is correct");				return;			} else {				for (String str : family) {					int in = BinarySearch(str, library[length - 2]);					if (in != -1							&& res.contains(library[length - 2].get(in)) == false) {						res.add(library[length - 2].get(in));					}				}				// for (Word w : library[length - 2]) {				// if (w.getWord().equals(str) && res.contains(w) == false) {				// res.add(w);				// }				// }			}		}		// long s2 = System.currentTimeMillis();		// System.out.println("t:" + (s2 - s1));		// long s1 = System.currentTimeMillis();		QuickSort(0, res.size() - 1, testString, res);		// long s2 = System.currentTimeMillis();		// System.out.println("t:" + (s2-s1));		int l = 0;		System.out.print(testString + ":");		for (l = 0; l < res.size(); l++) {			System.out.print(' ' + res.get(l).getWord());		}		System.out.println();// list.get(l).toStr());	}	static int BinarySearch(Word word, ArrayList<Word> lib) {		int high = lib.size() - 1;		int low = 0;		int mid;		while (low <= high) {			mid = (low + high) / 2;			if (word.getWord().compareTo(lib.get(mid).getWord()) > 0) {				low = mid + 1;			} else if (word.getWord().compareTo(lib.get(mid).getWord()) < 0) {				high = mid - 1;			} else {				return mid;			}		}		return -1;	}	static int BinarySearch(String word, ArrayList<Word> lib) {		int high = lib.size() - 1;		int low = 0;		int mid;		while (low <= high) {			mid = (low + high) / 2;			if (word.compareTo(lib.get(mid).getWord()) > 0) {				low = mid + 1;			} else if (word.compareTo(lib.get(mid).getWord()) < 0) {				high = mid - 1;			} else {				return mid;			}		}		return -1;	}	static ArrayList<String> getFamily(String s) {		ArrayList<String> family = new ArrayList<String>();		for (int i = 0; i < s.length(); i++) {// replace a char			char ith = s.charAt(i);			for (char a = 'a'; a <= 'z'; a++) {				if (ith != a) {					StringBuffer buffer = new StringBuffer(s);					buffer.setCharAt(i, a);					String replaceCharString = buffer.toString();					family.add(replaceCharString);				}			}		}		for (int j = 0; j <= s.length(); j++) {// 插入			for (char a = 'a'; a <= 'z'; a++) {				StringBuffer buffer = new StringBuffer(s);				StringBuffer bufferNewBuffer = buffer.insert(j, a);				family.add(bufferNewBuffer.toString());			}		}		for (int k = 0; k < s.length(); k++) {			StringBuffer buffer = new StringBuffer(s);			StringBuffer newBuffer = buffer.deleteCharAt(k);			if (newBuffer.length() > 0)				family.add(newBuffer.toString());		}		return family;	}	private static void QuickSort(int left, int right, String test,			ArrayList<Word> list) {		if (left < right) {			int pivotpos = partition(list, left, right);			QuickSort(left, pivotpos - 1, test, list);			QuickSort(pivotpos + 1, right, test, list);		}	}	private static int partition(ArrayList<Word> array, int left, int right) {		int pivotpos = left;		Word pivot = array.get(left);// [left];		for (int i = left + 1; i <= right; i++) {			if (array.get(i).getId() < pivot.getId()) {				pivotpos++;				if (pivotpos != i) {					Swap(array, pivotpos, i);				}			}		}		array.set(left, array.get(pivotpos));		array.set(pivotpos, pivot);		return pivotpos;	}	private static void Swap(ArrayList<Word> array, int pivotpos, int in) {		Word temp = array.get(in);		array.set(in, array.get(pivotpos));		array.set(pivotpos, temp);	}	private static void QuickSortL(int left, int right, ArrayList<Word> list) {		if (left < right) {			int pivotpos = partitionL(list, left, right);			QuickSortL(left, pivotpos - 1, list);			QuickSortL(pivotpos + 1, right, list);		}	}	private static int partitionL(ArrayList<Word> array, int left, int right) {		int pivotpos = left;		Word pivot = array.get(left);// [left];		for (int i = left + 1; i <= right; i++) {			if (array.get(i).getWord().compareTo(pivot.getWord()) < 0) {				pivotpos++;				if (pivotpos != i) {					SwapL(array, pivotpos, i);				}			}		}		array.set(left, array.get(pivotpos));		array.set(pivotpos, pivot);		return pivotpos;	}	private static void SwapL(ArrayList<Word> array, int pivotpos, int in) {		Word temp = array.get(in);		array.set(in, array.get(pivotpos));		array.set(pivotpos, temp);	}	static class Word {		int id;		String word;		public Word(int i, String s) {			this.id = i;			this.word = s;		}		public int getId() {			return id;		}		public void setId(int id) {			this.id = id;		}		public String getWord() {			return word;		}		public void setWord(String word) {			this.word = word;		}		public boolean equals(Object obj) {			Word w2 = (Word) obj;			if (word.equals(w2.getWord())) {				return true;			} else {				return false;			}		}	}}