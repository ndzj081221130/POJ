package p2513_euler_graph_runtime_error;import java.util.ArrayList; import java.util.Scanner; public class Main {	/**	 * @param args	 */	public static void main(String[] args) {		// TODO Auto-generated method stub//		Map<String, Integer>  map = new LinkedHashMap<String,Integer>();		Scanner scanner = new Scanner(System.in);		String lineString = scanner.nextLine();		if (lineString == null) {			System.out.println("Possible");			return;		}		Trie tree = new Trie(); 		int deg[]= new int[510005];		int father[] = new int[510005];		for(int i = 1; i <= 510000; i++)  	    {  	        father[i] = i;  	    }   		ArrayList<String> edges = new ArrayList<String>();		while(lineString != null && lineString.length() > 0){			String[] arrStrings = lineString.split(" ");			String left = arrStrings[0];			String right = arrStrings[1];			if(tree.has(left) == false){				tree.insert(left);			}			if(tree.has(right) == false) {				tree.insert(right);			} 			int x = tree.getIndex(left) ;			int y=  tree.getIndex(right);			deg[tree.getIndex(left)] ++;			deg[tree.getIndex(right)] ++;			int fx = find(x,father);  	        int fy = find(y,father);  	        if(fx != fy) Union(fx, fy,father);			lineString = scanner.nextLine();		}		int size = tree.getWordCount();		if(judge(size,deg,father)) System.out.println("Possible\n");  	    else System.out.println("Impossible\n"); 	}	static boolean judge(int cnt,int[]deg,int []father)    //判断是否满足欧拉  	{  	    int i, k, odd = 0;  	    for(i = 0; i < cnt; i++)  	    {  	        if(deg[i]%2 == 1) odd++;  	    }  	    if(odd != 0 && odd != 2) return false;  	    k = find(0,father);  	    for(i = 1; i < cnt; i++)  	    {  	        if(k != find(i,father)) return false;  	    }  	    return true;  	}  		static int find(int x,int[]father)  	{  	    if(x != father[x])  	    {  	        father[x] = find(father[x],father);  	    }  	    return father[x];  	}  	  	static void Union(int x, int y,int []father)  	{  	    father[x] = y;  	}  		 	static class Trie {     	    private int SIZE = 26;	    private TrieNode root;  //字典树的根	    private int wordCount = 0;	    public int getWordCount() {			return wordCount;		} 		Trie() {  //初始化字典树	        root = new TrieNode();  	    }  	  	    private class TrieNode {  //字典树节点	        private int num;//有多少单词通过这个节点,即节点字符出现的次数 	        private TrieNode[] son;// 所有的儿子节点	        private boolean isEnd;//是不是最后一个节点	        private char val;// 节点的值  	        private int index = -1;	        TrieNode() {  	            num = 1; 	            son = new TrieNode[SIZE];  	            isEnd = false;             	        }  	    }  	    	  //建立字典树	    public void insert(String str) {  //在字典树中插入一个单词	        if (str == null || str.length() == 0) {  	            return;	        }  	        TrieNode node = root;  	        char[] letters = str.toCharArray();  	        for (int i = 0, len = str.length(); i < len; i++) {  	            int pos = letters[i] - 'a';  	            if (node.son[pos] == null) {  	                node.son[pos] = new TrieNode();  	                node.son[pos].val = letters[i];   	            } else {  	                node.son[pos].num++; 	            }  	            node = node.son[pos];  	        }  	        node.isEnd = true;  	        node.index = wordCount;	        wordCount++;	    }  	  	     	    	      	    // 在字典树中查找一个完全匹配的单词.  	    public boolean has(String str) {  	        if (str == null || str.length() == 0) { 	             return false;  	        }  	        TrieNode node = root;  	        char[] letters=str.toCharArray();  	        for (int i = 0, len = str.length(); i < len; i++) {  	            int pos = letters[i] - 'a';  	            if (node.son[pos] != null) {  	                node = node.son[pos];  	            } else {  	                 return false;  	            }  	        }  	         return node.isEnd;  	    }  	  	    public int getIndex(String str) {  	        if (str == null || str.length() == 0) { 	             return -1;  	        }  	        TrieNode node = root;  	        char[] letters=str.toCharArray();  	        for (int i = 0, len = str.length(); i < len; i++) {  	            int pos = letters[i] - 'a';  	            if (node.son[pos] != null) {  	                node = node.son[pos];  	            } else {  	                 return -1;  	            }  	        }  	         return node.index;  	    }  	    	    //前序遍历字典树.  	    public void preTraverse(TrieNode node){  	        if(node!=null){  	            System.out.println(node.val+"-"  );	            	             for(TrieNode child: node.son){  	                preTraverse(child);  	            }  	        }          	    }  	   	    public TrieNode getRoot(){  	        return this.root;  	    }  	      	     	}  }