package p2513_euler_graph_runtime_error;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.Map;import java.util.Scanner;public class Main_map_runtimeError {	/**	 * @param args	 */	public static void main(String[] args) {		// TODO Auto-generated method stub		Map<String, Integer>  map = new LinkedHashMap<String,Integer>();		Scanner scanner = new Scanner(System.in);		String lineString = scanner.nextLine();		if (lineString == null) {			System.out.println("Possible");			return;		}		ArrayList<String> edges = new ArrayList<String>();		while(lineString != null && lineString.length() > 0){			String[] arrStrings = lineString.split(" ");			String left = arrStrings[0];			String right = arrStrings[1];			if (map.containsKey(left) == false) {				map.put(left, map.size());			}			if (map.containsKey(right) == false) {				map.put(right, map.size());			}			edges.add(map.get(left) +"," + map.get(right));			lineString = scanner.nextLine();		}		int size = map.size();		int[][] intEdges = new int[size][size];		for(String str:edges){			String[]arrStrings = str.split(",");			int i = Integer.parseInt(arrStrings[0]);			int j = Integer.parseInt(arrStrings[1]);			intEdges[i][j] = 1;			intEdges[j][i] = 1;//			System.out.println(i+","+j);		}				boolean flag = countOddDegree(intEdges,size);		if (flag == false) {			System.out.println("Impossible");			return;		}else{			boolean connectFlag = isConnect(intEdges, size);			if (connectFlag == false) {				System.out.println("Impossible");				return;			}else{				System.out.println("Possible");				return;			}		}	}	private static boolean isConnect(int[][] intEdges, int size) {		// TODO Auto-generated method stub				return DFS(intEdges,size);	}	static boolean DFS(int[][] edges,int size){		boolean[]visited = new boolean[size];		for (int i = 0; i < visited.length; i++) {			visited[i] = false;		}//		int loc = 		DFS(edges, 0, visited);		for (int i = 0; i < visited.length; i++) {			if (visited[i] == false) {				return false;			}		}		return true;	}		private static void DFS(int[][] edges, int v, boolean[] visited) {		// TODO Auto-generated method stub		visited[v] = true;		int w = getFirstNeightbor(edges,v);		while(w!=-1){			if (visited[w] == false) {				DFS(edges, w,visited);							}			w = getNextNeighbor(edges,v,w);		}	}	private static int getFirstNeightbor(int[][]edges,int v) {		// TODO Auto-generated method stub		if (v!=-1) {			for (int col = 0; col < edges.length; col++) {				if (edges[v][col] > 0  ) {					return col;				}			}		}		return -1; 	}	private static int getNextNeighbor(int[][]edges,int v, int w) {		// TODO Auto-generated method stub		if (v!=-1 && w!=-1) {			for (int col = w+1 ; col < edges.length; col++) {				if (edges[v][col] > 0 ) {					return col;				}			}		}		return -1;	}	private static boolean countOddDegree(int[][] intEdges, int size) {		// TODO Auto-generated method stub		int count = 0;		for (int i = 0; i < size; i++) {			int start = 0;			for (int j = 0; j < size; j++) {				start += intEdges[i][j];			}						if (start % 2 == 1) {//odd vertices 				count ++;			}			if(count > 2)				return false;		}		if(count == 0 || count == 2)			return true;		return false;	}}